Код решения
python
Копировать
from collections import defaultdict, deque

class DependencyGraph:
    def __init__(self):
        self.graph = defaultdict(list)
    
    # Добавление нового компонента (вершины)
    def add_component(self, name):
        if name not in self.graph:
            self.graph[name]
    
    # Установка зависимости от one к another
    def add_dependency(self, from_, to):
        self.add_component(from_)
        self.add_component(to)
        self.graph[from_].append(to)
    
    # Возвращает True, если граф не имеет циклов
    def is_acyclic(self):
        visited = set()
        recursion_stack = set()
        
        def dfs(node):
            visited.add(node)
            recursion_stack.add(node)
            
            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    if not dfs(neighbor):
                        return False
                elif neighbor in recursion_stack:
                    return False
                
            recursion_stack.remove(node)
            return True
        
        for node in self.graph.keys():
            if node not in visited and not dfs(node):
                return False
        
        return True
    
    # Выполняет топологическую сортировку
    def get_topological_order(self):
        result = []
        visited = set()
        
        def dfs(node):
            visited.add(node)
            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    dfs(neighbor)
            result.append(node)
        
        for node in list(self.graph.keys()):
            if node not in visited:
                dfs(node)
        
        return result[::-1] if len(result) == len(self.graph) else None

class DependencyAnalyzer:
    def __init__(self, graph):
        self.graph = graph
    
    # Нахождение зависимостей методом BFS
    def find_dependencies_bfs(self, start):
        levels = {}
        queue = deque([start])
        level = 0
        while queue:
            size = len(queue)
            current_level = []
            for _ in range(size):
                vertex = queue.popleft()
                if vertex not in levels:
                    levels[vertex] = level
                    current_level.append(vertex)
                    for dependency in self.graph.graph.get(vertex, []):
                        queue.append(dependency)
            level += 1
            yield current_level
    
    # Нахождение зависимостей методом DFS
    def find_dependencies_dfs(self, start):
        visited = set()
        stack = [start]
        dependencies = set()
        
        while stack:
            vertex = stack.pop()
            if vertex not in visited:
                visited.add(vertex)
                dependencies.add(vertex)
                for dependency in self.graph.graph.get(vertex, []):
                    stack.append(dependency)
        
        return dependencies

# Тестирование программы
if __name__ == "__main__":
    dg = DependencyGraph()
    dg.add_dependency("A", "B")
    dg.add_dependency("A", "C")
    dg.add_dependency("B", "D")
    dg.add_dependency("C", "D")
    dg.add_dependency("C", "E")
    dg.add_dependency("E", "B")  # Этот пример включает цикл!

    analyzer = DependencyAnalyzer(dg)

    print("Граф свободен от циклов:", dg.is_acyclic())
    print("Порядок сборки:", dg.get_topological_order())

    bfs_result = list(analyzer.find_dependencies_bfs("A"))
    print("Зависимости по уровням (BFS):", bfs_result)

    dfs_result = analyzer.find_dependencies_dfs("A")
    print("Все зависимости (DFS):", dfs_result)
